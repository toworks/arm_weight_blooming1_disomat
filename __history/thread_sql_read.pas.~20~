unit thread_sql_read;


interface

uses
  SysUtils, Data.DB, Classes, ActiveX, ZDataset, SyncObjs;

type
  //Здесь необходимо описать класс TThreadSql:
  TThreadSqlRead = class(TThread)

  private
    cs: TCriticalSection;

    function SqlReadTable(InData: string): boolean;
    procedure SqlNewRecord;
  protected
    procedure Execute; override;
  public
    Constructor Create; overload;
    Destructor Destroy; override;
  end;

var
  ThreadSqlRead: TThreadSqlRead;
  SqlMax: int64 = 0;
  FutureDate: TDateTime;


//  {$DEFINE DEBUG}


implementation

uses
  main, logging, settings, thread_comport, sql;




constructor TThreadSqlRead.Create;
begin
  inherited;
  cs := TCriticalSection.Create;

  // создаем поток True - создание остановка, False - создание старт
  ThreadSqlRead := TThreadSqlRead.Create(True);
  ThreadSqlRead.Priority := tpNormal;
  ThreadSqlRead.FreeOnTerminate := True;
  ThreadSqlRead.Start;
end;


destructor TThreadSqlRead.Destroy;
begin
  if ThreadSqlRead <> nil then begin
    FreeAndNil(cs);
    ThreadSqlRead.Terminate;
  end;
  inherited Destroy;
end;


procedure TThreadSqlRead.Execute;
begin
  CoInitialize(nil);
  while True do
   begin
      try
          Synchronize(SqlNewRecord);
      except
        on E : Exception do
          Log.save('e', E.ClassName+', с сообщением: '+E.Message);
      end;

      sleep(1000);
   end;
   CoUninitialize;
end;


procedure TThreadSqlRead.SqlNewRecord;
var
  FQueryNewRecord: TZQuery;
  SQueryCount: TZQuery;
  pkdat_in: string;
  i, timestamp: integer;
  count: int64;
begin
  FQueryNewRecord := TZQuery.Create(nil);
  FQueryNewRecord.Connection := FConnect;

  SQueryCount := TZQuery.Create(nil);
  SQueryCount.Connection := Settings.SConnect;

  // двигаем мышку
  try
      if NOW > FutureDate then
      begin
        FutureDate := Now + 4 / (24 * 60); //+4 minutes
        MouseMoved;//views взвешенные заготовки
      end;
  {$IFDEF DEBUG}
    Log.save('d', 'NOW -> '+datetimetostr(now));
    Log.save('d', 'FutureDate -> '+datetimetostr(FutureDate));
  {$ENDIF}
  except
    on E : Exception do
      Log.save('e', E.ClassName+', с сообщением: '+E.Message);
  end;

  try
    FQueryNewRecord.Close;
    FQueryNewRecord.SQL.Clear;
    FQueryNewRecord.SQL.Add('select distinct pkdat from ingots');
    FQueryNewRecord.SQL.Add('group by pkdat');
    FQueryNewRecord.SQL.Add('order by pkdat desc rows 3');
    FQueryNewRecord.Open;

    //подготавливаем данные для выборки в dbgrid
    i:=0;
    while not FQueryNewRecord.Eof do
    begin
      if i = 0 then
        pkdat_in := ''''+FQueryNewRecord.FieldByName('pkdat').AsString+''''
      else
        pkdat_in := pkdat_in+','+''''+FQueryNewRecord.FieldByName('pkdat').AsString+'''';
      inc(i);
      FQueryNewRecord.Next;
    end;

    count := 0;
    FQueryNewRecord.Close;
    FQueryNewRecord.SQL.Clear;
    FQueryNewRecord.SQL.Add('select pkdat||num||num_ingot as c from ingots');
    FQueryNewRecord.SQL.Add('order by pkdat desc, num desc ,num_ingot desc');
    FQueryNewRecord.SQL.Add('rows 1');
    FQueryNewRecord.Open;

    count := FQueryNewRecord.FieldByName('c').AsLargeInt;

    FreeAndNil(FQueryNewRecord);

    if (SqlMax < count) then
    begin
        SqlMax := count;
        //обновление отображение записанных данных ViewDbWeight;
        SqlReadTable(pkdat_in);

        //dbgrid текущая выбраная заготовка
        if not pkdat.IsEmpty then
          NextWeightToRecordLocation;

  {$IFDEF DEBUG}
    Log.save('d', 'count -> '+inttostr(count));
    Log.save('d', 'SqlMax -> '+inttostr(SqlMax));
    Log.save('d', 'pkdat_in -> '+pkdat_in);
  {$ENDIF}
     end;
  except
    on E : Exception do
      Log.save('e', E.ClassName+', с сообщением: '+E.Message);
  end;

  // маркер следующей заготовки
  if MarkerNextWait then
    NextWeightToRecord; //следующая запись (слиток) от записаной

  //-- локальные данные
  try
      if SqlMaxLocal = 0 then
      begin
          SQueryCount.Close;
          SQueryCount.SQL.Clear;
          SQueryCount.SQL.Add('select * from sqlite_master');
          SQueryCount.SQL.Add('where type = ''table'' and tbl_name = ''weight''');
          SQueryCount.Open;

          if SQueryCount.FieldByName('tbl_name').IsNull then
          begin
            FreeAndNil(SQueryCount);
            exit;
          end;
      end;

      SQueryCount.Close;
      SQueryCount.SQL.Clear;
      SQueryCount.SQL.Add('SELECT timestamp');
      SQueryCount.SQL.Add('FROM weight');
      SQueryCount.SQL.Add('order by timestamp desc limit 1');
      SQueryCount.Open;

      timestamp := SQueryCount.FieldByName('timestamp').AsInteger;
      FreeAndNil(SQueryCount);

      if SqlMaxLocal >= timestamp then
        exit;

      SqlMaxLocal := timestamp;
      cs.Enter;
      //views взвешенные заготовки
      Synchronize(SqlReadTableLocal);
      cs.Leave;
  except
    on E : Exception do
      Log.save('e', E.ClassName+', с сообщением: '+E.Message);
  end;
  //-- локальные данные
end;


function TThreadSqlRead.SqlReadTable(InData: string): boolean;
begin
  try
      FQuery.Close;
      FQuery.SQL.Clear;
      FQuery.SQL.Add('select i.pkdat,i.num,i.num_ingot,h.num_heat, s.name,i.weight_ingot, i.time_ingot, s.steel_group, sh.smena');
      FQuery.SQL.Add('from ingots i, heats h, steels s, shifts sh');
      FQuery.SQL.Add('where i.pkdat=h.pkdat');
      FQuery.SQL.Add('and i.pkdat=sh.pkdat');
      FQuery.SQL.Add('and i.num=h.num');
      FQuery.SQL.Add('and h.steel_grade=s.steel_grade');
      FQuery.SQL.Add('and i.pkdat in ('+InData+')');
      FQuery.SQL.Add('order by i.pkdat desc, i.num desc, i.num_ingot desc');
      FQuery.Open;
  except
    on E : Exception do
      Log.save('e', E.ClassName+', с сообщением: '+E.Message);
  end;
  //исправляем отображение даты в DBGrid -> pFIBDataSet1
  TDateTimeField(FQuery.FieldByName('time_ingot')).DisplayFormat:='hh:nn:ss';
end;


// При загрузке программы класс будет создаваться
initialization
//ThreadSqlRead := TThreadSqlRead.Create;


// При закрытии программы уничтожаться
finalization
//ThreadSqlRead.Destroy;


end.

