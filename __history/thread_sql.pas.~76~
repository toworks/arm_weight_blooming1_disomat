unit thread_sql;


interface

uses
  SysUtils, Classes, Windows, ActiveX, Graphics, Forms, pFIBQuery, ZDataset;

type
  //Здесь необходимо описать класс TThreadSql:
  TThreadSql = class(TThread)

  private
    { Private declarations }
  protected
    procedure Execute; override;
  end;

var
  ThreadSql: TThreadSql;
  SqlMax: integer = 0;
  FutureDate: TDateTime;


  function ThreadSqlInit: bool;
  function SqlNewRecord: bool;
  procedure WrapperSql;//обертка для синхронизации и выполнения с другим потоком
  function Status: string;


//  {$DEFINE DEBUG}


implementation

uses
  main, logging, settings, module, thread_comport, sql;





procedure TThreadSql.Execute;
begin
  CoInitialize(nil);
  while True do
   begin
      Synchronize(WrapperSql);
      sleep(1000);
   end;
   CoUninitialize;
end;


function ThreadSqlInit: bool;
begin
  //создаем поток
  ThreadSql := TThreadSql.Create(False);
  ThreadSql.Priority := tpNormal;
  ThreadSql.FreeOnTerminate := True;
end;


procedure WrapperSql;
begin
  try
      Application.ProcessMessages;//следующая операция не тормозит интерфейс
      SqlNewRecord;
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;
end;


function SqlNewRecord: bool;
var
  FQueryNewRecord: TpFIBQuery;
  SQueryCount: TZQuery;
  pkdat_in: string;
  i, count: integer;
begin
  FQueryNewRecord := TpFIBQuery.Create(nil);
  FQueryNewRecord.Database := Module1.pFIBDatabase1;
  FQueryNewRecord.Transaction := Module1.pFIBTransaction1;

  SQueryCount := TZQuery.Create(nil);
  SQueryCount.Connection := SConnect;

  Status;

  try
    FQueryNewRecord.Close;
    FQueryNewRecord.SQL.Clear;
    FQueryNewRecord.SQL.Add('select distinct pkdat from ingots');
    FQueryNewRecord.SQL.Add('group by pkdat');
    FQueryNewRecord.SQL.Add('order by pkdat desc rows 3');
    Application.ProcessMessages;//следующая операция не тормозит интерфейс
    FQueryNewRecord.ExecQuery;

    //подготавливаем данные для выборки в dbgrid
    i:=0;
    while not FQueryNewRecord.Eof do
    begin
      if i = 0 then
        pkdat_in := ''''+FQueryNewRecord.FieldByName('pkdat').AsString+''''
      else
        pkdat_in := pkdat_in+','+''''+FQueryNewRecord.FieldByName('pkdat').AsString+'''';
      inc(i);
      FQueryNewRecord.Next;
    end;

    count:=0;
    FQueryNewRecord.Close;
    FQueryNewRecord.SQL.Clear;
    FQueryNewRecord.SQL.Add('select pkdat||num||num_ingot as c from ingots');
//    FQueryNewRecord.SQL.Add('select cast(pkdat||num||num_ingot as integer) as c from ingots');
    FQueryNewRecord.SQL.Add('order by pkdat desc, num desc ,num_ingot desc');
    FQueryNewRecord.SQL.Add('rows 1');
    Application.ProcessMessages;//следующая операция не тормозит интерфейс
    FQueryNewRecord.ExecQuery;

    count := FQueryNewRecord.FieldByName('c').AsInt64;

    FreeAndNil(FQueryNewRecord);

    if SqlMax < count then
     begin
        SqlMax := count;
        //обновление отображение записанных данных ViewDbWeight;
        SqlReadTable(pkdat_in);

        //dbgrid текущая выбраная заготовка
        if not pkdat.IsEmpty then
          NextWeightToRecordLocation;

        //-- test -> при обновлении DBGrid записывается новая заготовка
        //--
        Form1.b_test.Click;

  {$IFDEF DEBUG}
    SaveLog('debug'+#9#9+'count -> '+inttostr(count));
    SaveLog('debug'+#9#9+'pkdat_in -> '+pkdat_in);
  {$ENDIF}
     end;
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;

  // маркер следующей заготовки
  if MarkerNextWait then
    SqlNextWeightToRecord;

  //-- локальные данные
  try
      if SqlMaxLocal = 0 then
      begin
          SLQuery.Close;
          SLQuery.SQL.Clear;
          SLQuery.SQL.Add('select * from sqlite_master');
          SLQuery.SQL.Add('where type = ''table'' and tbl_name = ''weight''');
          SLQuery.Open;

      if SLQuery.FieldByName('tbl_name').IsNull then
        exit;
      end;

      SQueryCount.Close;
      SQueryCount.SQL.Clear;
      SQueryCount.SQL.Add('SELECT timestamp');
      SQueryCount.SQL.Add('FROM weight');
      SQueryCount.SQL.Add('order by timestamp desc limit 1');
      SQueryCount.Open;

      if SqlMaxLocal >= SQueryCount.FieldByName('timestamp').AsInteger then
        exit;

      SqlMaxLocal := SQueryCount.FieldByName('timestamp').AsInteger;
      FreeAndNil(SQueryCount);
      //views взвешенные заготовки
      SqlReadTableLocal;
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;
  //-- локальные данные

  // двигаем мышку
  try
      if NOW > FutureDate then
      begin
        FutureDate := Now + 5 / (24 * 60); //+5 minutes
        MouseMoved;//views взвешенные заготовки
      end;
  {$IFDEF DEBUG}
    SaveLog('debug'+#9#9+'NOW -> '+datetimetostr(now));
    SaveLog('debug'+#9#9+'FutureDate -> '+datetimetostr(FutureDate));
  {$ENDIF}
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;

end;


function Status: string;
begin
  //сообщение оператору
  if pkdat.IsEmpty then
  begin
    ShowTrayMessage('Оператор', 'Для работы выбери взвешиваемую заготовку', 2);
    form1.l_status.Caption := 'выбор заготовки оператором';
  end
  else
    form1.l_status.Caption := '';

  if (not pkdat.IsEmpty) and (not no_save) then
    form1.l_status.Caption := 'ожидание данных с весов'
  else
    form1.l_status.Caption := '';

end;





end.

