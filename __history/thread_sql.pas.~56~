unit thread_sql;


interface

uses
  SysUtils, Classes, Windows, ActiveX, Graphics, Forms;

type
  //Здесь необходимо описать класс TThreadSql:
  TThreadSql = class(TThread)

  private
    { Private declarations }
  protected
    procedure Execute; override;
  end;

var
  ThreadSql: TThreadSql;
  SqlMax: integer = 0;


  function ThreadSqlInit: bool;
  function SqlNewRecord: bool;
  procedure WrapperSql;//обертка для синхронизации и выполнения с другим потоком


  {$DEFINE DEBUG}


implementation

uses
  main, logging, settings, module, sql;





procedure TThreadSql.Execute;
begin
  CoInitialize(nil);
  while True do
   begin
      Synchronize(WrapperSql);
      sleep(5000);
   end;
   CoUninitialize;
end;


function ThreadSqlInit: bool;
begin
  //создаем поток
  ThreadSql := TThreadSql.Create(False);
  ThreadSql.Priority := tpNormal;
  ThreadSql.FreeOnTerminate := True;
end;


procedure WrapperSql;
begin
  try
      Application.ProcessMessages;//следующая операция не тормозит интерфейс
      SqlNewRecord;
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;
end;


function SqlNewRecord: bool;
var
  pkdat_in: string;
  i, count: integer;
begin

  //сообщение оператору
  if pkdat.IsEmpty then
    ShowTrayMessage('Оператор', 'Для работы выбери взвешиваемую заготовку', 2);

  try
    Module1.pFIBQuery1.Close;
    Module1.pFIBQuery1.SQL.Clear;
    Module1.pFIBQuery1.SQL.Add('select distinct pkdat, count(pkdat) as count from ingots');
    Module1.pFIBQuery1.SQL.Add('group by pkdat');
    Module1.pFIBQuery1.SQL.Add('order by pkdat desc rows 3');
    Module1.pFIBQuery1.ExecQuery;

    i:=0;
    while Module1.pFIBQuery1.Eof do
    begin
      if i = 0 then
        pkdat_in := ''''+Module1.pFIBQuery1.FieldByName('pkdat').AsString+''''
      else
        pkdat_in := pkdat_in+','+''''+Module1.pFIBQuery1.FieldByName('pkdat').AsString+'''';

      count := count + Module1.pFIBQuery1.FieldByName('count').AsInt64;
      inc(i);
      Module1.pFIBQuery1.Next;
    end;
  {$IFDEF DEBUG}
    SaveLog('debug'+#9#9+'count -> '+inttostr(count));
    SaveLog('debug'+#9#9+'pkdat_in -> '+pkdat_in+');
  {$ENDIF}
exit;
    //подготавливаем дату для выборки dbgrid
    pkdat_in := copy(Module1.pFIBQuery1.FieldByName('max').AsString, 1, 6);

    if SqlMax < Module1.pFIBQuery1.FieldByName('count').AsInt64 then
     begin
        SqlMax := Module1.pFIBQuery1.FieldByName('count').AsInt64;
        //обновление отображение записанных данных ViewDbWeight;
        SqlReadTable(''''+pkdat_in+'1'','''+pkdat_in+'2'','''+pkdat_in+'3'','''+ManipulationWithDate(pkdat_in, 1)+'3''');

        //test -> при обновлении DBGrid записывается новая заготовка
        //Form1.b_test.Click;

  {$IFDEF DEBUG}
    SaveLog('debug'+#9#9+'count -> '+Module1.pFIBQuery1.FieldByName('count').AsString);
    SaveLog('debug'+#9#9+'pkdat_in -> '+''''+pkdat_in+'1'','''+pkdat_in+'2'','''+pkdat_in+'3'','''+ManipulationWithDate(pkdat_in, 1)+'3''');
  {$ENDIF}
     end;
  except
    on E : Exception do
      SaveLog('error'+#9#9+E.ClassName+', с сообщением: '+E.Message);
  end;
end;



end.

