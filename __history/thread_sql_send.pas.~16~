unit thread_sql_send;


interface

uses
  SysUtils, Classes, ActiveX, ZDataset;

type
  //Здесь необходимо описать класс TThreadSql:
  TThreadSqlSend = class(TThread)

  private
    procedure SqlSend;
  protected
    procedure Execute; override;
  public
    Constructor Create; overload;
    Destructor Destroy; override;
  end;

var
  ThreadSqlSend: TThreadSqlSend;


//  {$DEFINE DEBUG}


implementation

uses
  main, logging, settings, thread_comport, sql;




constructor TThreadSqlSend.Create;
begin
  inherited;
  // создаем поток True - создание остановка, False - создание старт
  ThreadSqlSend := TThreadSqlSend.Create(True);
  ThreadSqlSend.Priority := tpNormal;
  ThreadSqlSend.FreeOnTerminate := True;
  ThreadSqlSend.Start;
end;


destructor TThreadSqlSend.Destroy;
begin
  if ThreadSqlSend <> nil then begin
    ThreadSqlSend.Terminate;
  end;
  inherited Destroy;
end;


procedure TThreadSqlSend.Execute;
begin
  CoInitialize(nil);
  while True do
   begin
      try
          Synchronize(SqlSend);
      except
        on E : Exception do
          SaveLog('e', E.ClassName+', с сообщением: '+E.Message);
      end;
      sleep(500);
   end;
   CoUninitialize;
end;


procedure TThreadSqlSend.SqlSend;
var
  i: integer;
  Byffer: array of array of AnsiString;
  send_error: boolean;
begin

  SQuery.Close;
  SQuery.SQL.Clear;
  SQuery.SQL.Add('SELECT id_asutp, weight,');
  SQuery.SQL.Add('datetime(timestamp, ''unixepoch'', ''localtime'' ) as timestamp');
  SQuery.SQL.Add('FROM weight');
  SQuery.SQL.Add('where transferred=0');
  SQuery.SQL.Add('order by id asc limit 10'); //порциями по 10 шт
  SQuery.Open;

  i := 0;
  while not SQuery.Eof do
   begin
      if i = Length(Byffer) then SetLength(Byffer, i+1, 3);
      Byffer[i,0] := SQuery.FieldByName('id_asutp').AsString;
      Byffer[i,1] := SQuery.FieldByName('weight').AsString;
      Byffer[i,2] := SQuery.FieldByName('timestamp').AsString;
      inc(i);
      SQuery.Next;
   end;

  for i := Low(Byffer) to High(Byffer) do
   begin
    {$IFDEF DEBUG}
      SaveLog('d', 'id_asutp -> '+Byffer[i,0]);
      SaveLog('d', 'weight -> '+Byffer[i,1]);
      SaveLog('d', 'timestamp -> '+Byffer[i,2]);
    {$ENDIF}
      try
        send_error := SqlSaveToOracle(Byffer[i,0], Byffer[i,1], Byffer[i,2]);
//  {$IFDEF DEBUG}
    SaveLog('d', 'send_error | '+booltostr(send_error));
//  {$ENDIF}
        if not send_error then begin
            SQuery.Close;
            SQuery.SQL.Clear;
            SQuery.SQL.Add('UPDATE weight SET transferred=1');
            SQuery.SQL.Add('where id_asutp='+Byffer[i,0]+'');
            SQuery.ExecSQL;
            //save to log file
            {SaveLog('sql'+#9#9+'write'+#9+'id_asutp -> '+Byffer[i,0]);
            SaveLog('sql'+#9#9+'write'+#9+'weight -> '+Byffer[i,1]);
            SaveLog('sql'+#9#9+'write'+#9+'timestamp -> '+Byffer[i,2]);}

            SqlReadTableLocal;//views взвешенные заготовки

            //удаляем старые записи старше 3х дней
            SQuery.Close;
            SQuery.SQL.Clear;
            SQuery.SQL.Add('delete from weight');
            SQuery.SQL.Add('where timestamp < strftime(''%s'', ''now'') - (86400*3)');
            SQuery.ExecSQL;
        end;
      except
        on E : Exception do
          SaveLog('e', E.ClassName+', с сообщением: '+E.Message);
      end;
   end;
end;




// При загрузке программы класс будет создаваться
initialization
ThreadSqlSend := TThreadSqlSend.Create;


// При закрытии программы уничтожаться
finalization
ThreadSqlSend.Destroy;


end.

